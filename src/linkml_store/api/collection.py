from collections import defaultdict
from dataclasses import dataclass
from typing import Union, Dict, Type, Any, Optional, Iterable, List

from linkml_runtime.linkml_model import ClassDefinition, SlotDefinition
from pydantic import BaseModel

from linkml_store.api.queries import QueryResult, Query

OBJECT = Union[Dict[str, Any], BaseModel, Type]

IDENTIFIER = str
FIELD_NAME = str

@dataclass
class Collection:
    name: str
    parent: Optional['Database'] = None

    def add(self, objs: Union[OBJECT, List[OBJECT]]):
        if not isinstance(objs, list):
            objs = [objs]
        if not self.class_definition():
            raise ValueError(f"Class definition not found for {self.name}")



    def _create_query(self, **kwargs) -> Query:
        return Query(from_table=self.name, **kwargs)

    def query(self, query: Query, **kwargs) -> QueryResult:
        """
        Run a query against the collection

        :param query:
        :param kwargs:
        :return:
        """
        return self.parent.query(query, **kwargs)

    def query_facets(self, where: Dict = None, facet_columns: List[str] = None) -> Dict[str, Dict[str, int]]:
        """
        Run a query to get facet counts for one or more columns.

        This function takes a database connection, a Query object, and a list of column names.
        It generates and executes a facet count query for each specified column and returns
        the results as a dictionary where the keys are the column names and the values are
        pandas DataFrames containing the facet counts.

        The facet count query is generated by modifying the original query's WHERE clause
        to exclude conditions directly related to the facet column. This allows for counting
        the occurrences of each unique value in the facet column while still applying the
        other filtering conditions.

        :param con: A DuckDB database connection.
        :param query: A Query object representing the base query.
        :param facet_columns: A list of column names to get facet counts for.
        :return: A dictionary where keys are column names and values are pandas DataFrames
                 containing the facet counts for each unique value in the respective column.
        """
        raise NotImplementedError

    def get(self, ids: Optional[List[IDENTIFIER]] = None, where: Optional[Any] = None, **kwargs) -> QueryResult:
        if ids:
            raise NotImplementedError
        query = self._create_query(where_clause=where)
        return self.query(query, **kwargs)

    def find(self, where: Optional[Any] = None, **kwargs) -> QueryResult:
        query = self._create_query(where_clause=where)
        return self.query(query, **kwargs)

    def peek(self, limit: Optional[int] = None) -> QueryResult:
        q = self._create_query()
        return self.query(q, limit=limit)

    def identifier_field(self) -> FIELD_NAME:
        raise NotImplementedError

    def get(self, ids: Optional[IDENTIFIER], **kwargs) -> QueryResult:
        id_field = self.identifier_field
        q = self._create_query(where_clause={id_field: ids})
        return self.query(q, **kwargs)

    def class_definition(self) -> Optional[ClassDefinition]:
        sv = self.parent.schema_view
        if sv and self.name in sv.all_classes():
            return sv.get_class(self.name)
        return None

    def induce_class_definition_from_objects(self, objs: List[OBJECT]) -> ClassDefinition:
        """
        Induce a class definition from a list of objects
        """
        cd = ClassDefinition(self.name)
        keys = defaultdict(list)
        for obj in objs:
            if isinstance(obj, BaseModel):
                obj = obj.model_dump()
            for k, v in obj.items():
                keys[k].append(v)
        for k, vs in keys.items():
            multivalueds = []
            rngs = []
            for v in vs:
                if not v:
                    continue
                if isinstance(v, list):
                    v = v[0]
                    multivalueds.append(True)
                else:
                    multivalueds.append(False)
                if isinstance(v, dict):
                    v = list(v.values())[0]
                    multivalueds.append(True)
                else:
                    multivalueds.append(False)
                if not v:
                    continue
                if isinstance(v, str):
                    rng = "string"
                elif isinstance(v, bool):
                    rng = "boolean"
                elif isinstance(v, int):
                    rng = "integer"
                elif isinstance(v, float):
                    rng = "float"
                else:
                    raise ValueError(f"No mappings for {type(v)} // v={v}")
                rngs.append(rng)
            multivalued = any(multivalueds)
            if multivalued and False in multivalueds:
                raise ValueError(f"Mixed list non list: {vs}")
            rng = rngs[0]
            for other_rng in rngs:
                if rng != other_rng:
                    raise ValueError(f"Conflict: {rng} != {other_rng} for {vs}")
            cd.attributes[k] = SlotDefinition(k, range=rng)
        sv = self.parent.schema_view
        sv.schema.classes[self.name] = cd
        return cd


